# Chapter 10. 코루틴의 이해

## 10.1. 서브루틴과 코루틴

### 10.1.1. 루틴과 서브루틴

- 함수 또는 메서드를 루틴이라고 보면 됨
- 함수 내에서 호출된 함수를 서브루틴이라고 부름

### 10.1.2. 서브루틴과 코루틴의 차이

- 코루틴은 함께(Co) 실행되는 루틴으로 서로 간에 스레드 사용을 양보하며 함께 실행된다.

## 10.2. 코루틴의 스레드 양보

- 스레드를 양보하는 주체는 코루틴이다.

## 10.3. 코루틴의 실행 스레드

### 10.3.1. 코루틴의 실행 스레드는 고정이 아니다

- CoroutineDispatcher 객체는 쉬고 있 스레드에 코루틴을 할당해 실행하기 때문에 코루틴은 일시 중단 전 실행되던 스레드와 재개 후 실행되는 스레드가 다를 수 있다.
![image](https://github.com/user-attachments/assets/8f9698f8-1a06-40b5-b863-8badf1e9a839)

### 10.3.2. 스레드를 양보하지 않으면 실행 스레드가 바뀌지 않는다

- 코루틴의 실행 스레드가 바뀌는 시점은 코루틴이 재개될 때이다
- 따라서 코루틴이 스레드를 양보하지 않아 일시 중단될 일이 없다면 실행 스레드는 바뀌지 않는다.
- 스레드를 양보하지 않으면 코루틴을 사용하는 이점이 모두 사라지게 되므로 이런 코드는 지양해야 한다.

## 10.4. 요약

1. 프로그래밍에서는 루틴을 '특정한 일을 처리하기 위한 일련의 명령'이라는 뜻으로 사용하고 있으며, 이런 일련의 명령을 함수 또는 메서드라고 한다.
2. 서브루틴은 루틴의 하위에서 실행되는 루틴이다. 즉, 함수 내부에서 호출되는 함수를 서브루틴이라고 한다.
3. 서브루틴은 한 번 실행되면 끝까지 실행되는 반면에 코루틴은 서로 간에 스레드 사용 권한을 양보하며 함께 실행된다.
4. delay 함수는 스레드를 양보하고 일정 시간 동안 코루틴을 일시 중단시킨다.
5. join과 await 함수를 호출한 코루틴은 join이나 await의 대상이 된 코루틴의 작업이 완료될 때까지 스레드를 양보하고 일시 중단한다.
6. yield 함수는 스레드 사용 권한을 명시적으로 양보하고자 할 때 사용한다.
7. 코루틴은 협력적으로 동작한다. 코루틴은 스레드 사용 권한을 양보함으로써 스레드가 실제로 사용되지 않는 동안 다른 코루틴이 스레드를 사용할 수 있도록 한다.
8. 코루틴이 스레드를 양보하면 코루틴은 일시 중단되며, 재개될 때 CoroutineDispatcher 객체를 통해 다시 스레드에 보내진다. CoroutineDispatcher 객체는 코루틴을 쉬고 있는 스레드 중 하나에 보내므로 일시 중단 전의 스레드와 다른 스데ㅡ에서 재개될 수 있다.
9. 코루틴이 스레드를 양보하지 않으면 실행 스레드가 바뀌지 않는다.
10. 코루틴 내부에서 Thread.sleep 함수를 사용하면 코루틴이 대기하는 시간 동안 스레드를 양보하지 않고 블로킹한다.
